start
  = body

/*-------------------------------------------------------------------------------------------------------------------------------------
   body is defined as anything that matches with the part 0 or more times
---------------------------------------------------------------------------------------------------------------------------------------*/
body
  = p:item*

item
  = section / yield / include / buffer

buffer
  = e:eol w:ws*
  { return [ "buffer", {line: line(), column: column()}, e, w.join('') ] }
  / b:(!section !section_stop !include !yield c:. { return c })+
  { return [ "buffer", {line: line(), column: column()}, b.join('') ] }

include
  = "@include" name:tag_name a:after_tag {
      return ['include', {line: line(), column: column()}, name, ['after'].concat(a)]
  }

section
  = "@section" name:tag_name eol:eol? body:body n:section_stop? {
      return ['section', {line: line(), column: column()}, name, ['content', body], {end: n}]
  }

tag_name
  = open_brace out:(!quote c:. {return c})+ close_brace { return out.join("") }

yield
  = "@yield" name:tag_name a:after_tag {
      return ['yield', {line: line(), column: column()}, name, ['after'].concat(a)]
  }

section_stop "section stop"
  = "@stop" b:eol? { return line() }

after_tag
  = w:ws? e:eol? { return [ w || '', e || '' ] }
  
quote
  = '"'

open_brace
  = '(' quote

close_brace
  = quote ')'

any
  = (after:. {return after})+

eol
  = "\n"        //line feed
  / "\r\n"      //carriage + line feed
  / "\r"        //carriage return
  / "\u2028"    //line separator
  / "\u2029"    //paragraph separator

ws
  = [\t\v\f \u00A0\uFEFF] / eol

