start
  = body

/*-------------------------------------------------------------------------------------------------------------------------------------
   body is defined as anything that matches with the part 0 or more times
---------------------------------------------------------------------------------------------------------------------------------------*/
body
  = p:item*

item
  = helper / reference / buffer

buffer
  = e:eol w:ws*
  { return [ "buffer", {line: line(), column: column()}, e, w.join('') ] }
  / b:(!helper !tag c:. { return c })+
  { return [ "buffer", {line: line(), column: column()}, b.join('') ] }

/**
 * ----------------------------------------------------------------------
 * Helper Tags
 * ----------------------------------------------------------------------
 */

helper
  = ld t:[@#] n:identifier p:params rd a:after_tag {
    return [t, {line: line(), column: column(), name: n.text, after: a, params: p}]
  }

/*
include
  = "@include" name:tag_name a:after_tag {
      return ['include', {line: line(), column: column()}, name, ['after'].concat(a)]
  }

section
  = "@section" name:tag_name eol:eol? body:body n:section_stop? {
      return ['section', {line: line(), column: column()}, name, ['content', body], {end: n}]
  }

tag_name
  = open_brace out:(!quote c:. {return c})+ close_brace { return out.join("") }

yield
  = "@yield" name:tag_name a:after_tag {
      return ['yield', {line: line(), column: column()}, name, ['after'].concat(a)]
  }
*/

section_stop "section stop"
  = "@stop" b:eol? { return line() }

after_tag
  = w:ws? e:eol? { return [ w || '' + e || '' ] }

key "key"
  = h:[a-zA-Z_$] t:[0-9a-zA-Z_$-]*
  { return h + t.join('') }

params "params"
  = p:(ws+ k:key "=" v:(number / identifier / inline) {return ["param", ["literal", k], v]})*
  { return p }

identifier "identifier"
  = p:path     { var arr = ["path"].concat(p); arr.text = p[1].join('.'); return arr; }
  / k:key      { var arr = ["key", k]; arr.text = k; return arr; }

number "number"
  = n:(float / integer) { return ['literal', n]; }

float "float"
  = l:integer "." r:integer+ { return parseFloat(l + "." + r.join('')); }

integer "integer"
  = digits:[0-9]+ { return parseInt(digits.join(""), 10); }

path "path"
  = k:key? d:(array_part / array)+ {
    d = d[0];
    if (k && d) {
      d.unshift(k);
      return [false, d].concat([['line', line()], ['col', column()]]);
    }
    return [true, d].concat([['line', line()], ['col', column()]]);
  }
  / "." d:(array_part / array)* {
    if (d.length > 0) {
      return [true, d[0]].concat([['line', line()], ['col', column()]]);
    }
    return [true, []].concat([['line', line()], ['col', column()]]);
  }

inline "inline"
  = '"' '"'                 { return ["literal", ""].concat([['line', line()], ['col', column()]]) }
  / '"' l:literal '"'       { return ["literal", l].concat([['line', line()], ['col', column()]]) }
  / '"' p:inline_part+ '"'  { return ["body"].concat(p).concat([['line', line()], ['col', column()]]) }

inline_part
  = reference / l:literal { return ["buffer", l] }

key "key"
  = h:[a-zA-Z_$] t:[0-9a-zA-Z_$-]*
  { return h + t.join('') }

array "array"
  = i:( lb a:( n:([0-9]+) {return n.join('')} / identifier) rb  {return a; }) nk: array_part? { if(nk) { nk.unshift(i); } else {nk = [i] } return nk; }

array_part "array_part"
  = d:("." k:key {return k})+ a:(array)? { if (a) { return d.concat(a); } else { return d; } }

literal "literal"
  = b:(!tag c:(esc / [^"]) {return c})+
  { return b.join('') }

reference "reference"
  = ld n:identifier f:filters rd a:after_tag {
    return ["reference", {line: line(), column: column(), name: n.text, after: a, filters: f}]
  }

tag
  = ld ws* [#?^><+%:@/~%] ws* (!rd !eol .)+ ws* rd
  / reference

filters "filters"
  = f:("|" n:key {return n})*
  { return f }

esc
  = '\\"' { return '"' }

rawcontent
  = c:(char:. {return char})* {return c}

quote
  = '"'

ld
  = "{"

rd
  = "}"

lb
  = "["

rb
  = "]"
any
  = (after:. {return after})+

eol
  = "\n"        //line feed
  / "\r\n"      //carriage + line feed
  / "\r"        //carriage return
  / "\u2028"    //line separator
  / "\u2029"    //paragraph separator

ws
  = [\t\v\f \u00A0\uFEFF] / eol

